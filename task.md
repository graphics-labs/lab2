| Лабораторная работа №2Примитивы OpenGl

  Точки, линии, треугольники, четырехугольники, многоугольники - простые объекты, из которых состоят любые сложные фигуры. В предыдущей главе мы рисовали сферу, конус и тор. OpenGL непосредственно не поддерживает функций для создания таких сложных объектов, т.е. таких функций нет в opengl32.dll. Эти функции есть в библиотеке утилит glu32.dll, и устроены они следующим образом. Для того чтобы нарисовать сферу, функция glutauxSolidSphere использует функции из библиотеки glu32.dll, а те в свою очередь, используют базовую библиотеку opengl32.dll и из линий или многоугольников строят сферу. Примитивы создаются следующим образом: glBegin(GLenum mode); // указываем, что будем рисовать glVertex[2 3 4][s i f d](...); // первая вершина... // тут остальные вершины glVertex[2 3 4][s i f d](...); // последняя вершинаglEnd(); // закончили рисовать примитив      Сначала вы говорите, что будете рисовать - glBegin с соответсвующим параметром. Возможные значения mode перечислены ниже в таблице. Далее вы указываете вершины, определяющие объекты указанного типа. Обычно, вы будете задавать вершину одним из четырех способов. glVertex2d(x,y); // две переменных типа doubleglVertex3d(x,y,z); // три переменных типа doubleglVertex2dv(array); // массив из двух переменных типа doubleglVertex3d(array); // массив из трех переменных типа doubleИ, наконец, вы вызваете glEnd, чтобы указать, что вы закончили рисовать объекты типа, указанного в glBegin. Далее мы подробно разберем создание всех примитивов.

| Значение mode | Описание |
| --- | --- |
| GL\_POINTS | Каждый вызов glVertex задает отдельную точку. |
| --- | --- |
| GL\_LINES | Каждая пара вершин задает отрезок. |
| --- | --- |
| GL\_LINE\_STRIP | Рисуется ломаная. |
| --- | --- |
| GL\_LINE\_LOOP | Рисуется ломаная, причем ее последняя точка соединяется с первой. |
| --- | --- |
| GL\_TRIANGLES | Каждые три вызова glVertex задают треугольник. |
| --- | --- |
| GL\_TRIANGLE\_STRIP | Рисуются треугольники с общей стороной. |
| --- | --- |
| GL\_TRIANGLE\_FAN | Тоже самое, но по другому правилу соединяются вершины, вряд ли понадобится. |
| --- | --- |
| GL\_QUADS | Каждые четыре вызова glVertex задают четырехугольник. |
| --- | --- |
| GL\_QUAD\_STRIP | Четырехугольники с общей стороной. |
| --- | --- |
| GL\_POLYGON | Многоугольник. |
| --- | --- |

 |
| --- |
|
 |

Точки

     Вы можете нарисовать столько точек, сколько вам нужно. Вызывая glVertex3d, вы устанавливаете новую точку. При создании точек вы можете изменять следующие параметры. Вы можете вызывать glColor3d внутри glBegin/glEnd. Размер точки можно устанавливать с помощью функции:

void glPointSize(GLfloat size)

Режим сглаживания можно устанавливать вызовом функции

glEnable(GL\_POINT\_SMOOTH)

     Отключается, соответственно, вызовом glDisable() c этим параметром. Последние функции - glPointSize и glEnable/glDisable надо вызывать вне glBegin/glEnd, иначе они будут проигнорированы. Функции glEnable/glDisable включают/выключают множество опций, но вы должны учитывать, что некоторые опции влекут за собой большие вычисления и, следовательно, изрядно затормаживают ваше приложение, поэтому без надобности не стоит их включать. Очевидно, что совершенно не к чему включать освещение, наложение текстры и сглаживания цветов при рисовании точек. Пока вы с этими возможностями OpenGL не познакомились, поэтому запомните это на будующее.

// рисуемточки

glPointSize(2);

glBegin(GL\_POINTS);

glColor3d(1,0,0);

glVertex3d(-4.5,4,0); // перваяточка

glColor3d(0,1,0);

glVertex3d(-4,4,0); // втораяточка

glColor3d(0,0,1); // третья

glVertex3d(-3.5,4,0);

glEnd();

glPointSize(5);

glBegin(GL\_POINTS);

glColor3d(1,0,0);

glVertex3d(-2,4,0); // перваяточка

glColor3d(0,1,0);

glVertex3d(-1,4,0); // втораяточка

glColor3d(0,0,1); // третье

glVertex3d(0,4,0);

glEnd();

glPointSize(10);

glEnable(GL\_POINT\_SMOOTH);

glBegin(GL\_POINTS);

glColor3d(1,0,0);

glVertex3d(2,4,0); // перваяточка

glColor3d(0,1,0);

glVertex3d(3,4,0); // втораяточка

glColor3d(0,0,1); // третья

glVertex3d(4,4,0);

glEnd();

glDisable(GL\_POINT\_SMOOTH);

**Линии**

Для линий вы также можете изменять ширину, цвет, размер, сглаживание. Если вы зададите разные цвета для начала и конца линии, то ее цвет будет переливающимся. OpenGL по умолчанию делает интерполяцию. Так же вы можете рисовать прерывистые линии, делается это путем наложения маски при помощи следующей функции:

void glLineStipple(GLint factor, GLushort pattern );

    Второй параметр задает саму маску. Например, если его значение равно 255(0x00FF), то, чтобы вычислить задаваемую маску, воспользуемся калькулятором. В двоичном виде это число выглядит так: 0000000011111111, т.е. всего 16 бит. Старшие восемь установлены в ноль, значит тут линии не будет. Младшие установлены в единицу, тут будет рисоваться линия. Первый параметр определяет, сколько раз повторяется каждый бит. Скажем, если его установить равным 2, то накладываемая маска будет выглядить так:

00000000000000001111111111111111

Далее приведен исходный текст с комментариями для наглядной демонстрации, что к чему.

glLineWidth(1); // ширину линии

// устанавливаем 1

glBegin(GL\_LINES);

glColor3d(1,0,0); // красный цвет

glVertex3d(-4.5,3,0); // первая линия

glVertex3d(-3,3,0);

glColor3d(0,1,0); // зеленый

glVertex3d(-3,3.3,0); // вторая линия

glVertex3d(-4,3.4,0);

glEnd();

glLineWidth(3); // ширина 3

glBegin(GL\_LINE\_STRIP); // см. ниже

glColor3d(1,0,0);

glVertex3d(-2.7,3,0);

glVertex3d(-1,3,0);

glColor3d(0,1,0);

glVertex3d(-1.5,3.3,0);

glColor3d(0,0,1);

glVertex3d(-1,3.5,0);

glEnd();

glLineWidth(5);

glEnable(GL\_LINE\_SMOOTH);

glEnable(GL\_LINE\_STIPPLE); // разрешаемрисовать

// прерывистую линию

glLineStipple(2,58360); // устанавливаем маску

// пояснения см. ниже

glBegin(GL\_LINE\_LOOP);

glColor3d(1,0,0);

glVertex3d(1,3,0);

glVertex3d(4,3,0);

glColor3d(0,1,0);

glVertex3d(3,2.7,0);

glColor3d(0,0,1);

glVertex3d(2.5,3.7,0);

glEnd();

glDisable(GL\_LINE\_SMOOTH);

glDisable(GL\_LINE\_STIPPLE);

**Треугольники**

Для треугольника можно задавать те же параметры, что и для линии, плюс есть еще одна функция glPolygonMode. Она устанавливает опции для отрисовки многоугольника. Первый параметр может принимать значения - GL\_FRONT, GL\_BACK и GL\_FRONT\_AND\_BACK. Второй параметр указывает, как будет рисоваться многоугольник. Он принимает значения: GL\_POINT(рисуются только точки), GL\_LINE(рисуем линии) и GL\_FILL(рисуем заполненный многоугольник). Первый параметр указывает: к лицевой, тыльной или же к обеим сторонам применяется опция, заданная вторым параметром. Треугольники можно рисовать, передав GL\_TRIANGLE\_STRIP или GL\_TRIANGLE\_FAN в glBegin. В первом случае, первая, вторая и третья вершины задают первый треугольник. Вторая, третья и четвертая вершина - второй треугольник. Третья, четвертая и пятая вершина - третий треугольник и т.д. Вершины n, n+1 и n+2 определят n-ый треугольник. Во втором случае, первая, вторая и третья вершина задают первый треугольник. Первая, третья и четвертая вершины задают второй треугольник и т.д. Вершины 1, n+1, n+2 определяют n-ый треугольник. Далее следует пример с комментариями.

glPolygonMode(GL\_FRONT\_AND\_BACK, GL\_FILL); // см. выше

glBegin(GL\_TRIANGLES);

glColor3d(1,0,0); // рисуемтреугольник

glVertex3d(-4,2,0);

glVertex3d(-3,2.9,0);

glVertex3d(-2,2,0);

glEnd();

glLineWidth(2);

glPolygonMode(GL\_FRONT\_AND\_BACK, GL\_LINE); //рисуем

// проволочные треугольники

glBegin(GL\_TRIANGLE\_STRIP); // обратите внимание на порядок

// вершин

glColor3d(0,1,0);

glVertex3d(1,2,0);

glVertex3d(0,2.9,0);

glVertex3d(-1,2,0);

glVertex3d(0,1.1,0);

glEnd();

glEnable(GL\_LINE\_STIPPLE);

glPolygonMode(GL\_FRONT\_AND\_BACK, GL\_LINE);

glBegin(GL\_TRIANGLE\_FAN);

glColor3d(0,0,1);

glVertex3d(4,2,0);

glVertex3d(2.6,2.8,0);

glVertex3d(2,2,0);

glVertex3d(3,1.1,0);

glEnd();

glDisable(GL\_LINE\_STIPPLE);

**Четырехугьники**

Четырехугольники рисуются вызовом функции glBegin с параметром GL\_QUADS или GL\_QUAD\_STRIP. Для первого случая каждые четыре вершины определяют свой четырехугольник. Во втором случае рисуются связанные четырехугольники. Первая, вторая, третья и четвертая вершина определяют первый четырехугольник. Третья, четвертая, пятая и шестая вершина - второй четырехугольник и т.д. (2n-1), 2n, (2n+1) и (2n+2) вершины задают n-ый четырехугольник. Многоугольники задаются вызовом glBegin с параметром GL\_POLYGON. Все вершины определяют один многоугольник. Для многоугольников можно задавать стили при помощи вышеописанной функции glPolygonMode, толщину линии, толщину точек и цвет.

Задание на лабораторную работу

1. Изобразить точки, линии, треугольники, многоугольники в одном окне, как показано ниже.

![](RackMultipart20220915-1-nf07uk_html_aebfeb3f2c54836f.jpg)

Дополнительные задания к лабораторной №2

По курсу «КиИГ.

1. Изобразить в виде розетки треугольников окружность

![](RackMultipart20220915-1-nf07uk_html_ce9e7371f465e1ee.gif) ![](RackMultipart20220915-1-nf07uk_html_2da13369109e3caf.gif) ![](RackMultipart20220915-1-nf07uk_html_680b8cddabac569c.gif)

Изменять число элементов в розетке для получения качественного изображения окружности.

2. Изобразить в виде многоугольников правильную звездочку.

![](RackMultipart20220915-1-nf07uk_html_1883f3bdd774cb7c.gif)

Выполнить сплошную и сглаженную заливку звездочки.

3. Изобразить букву

## **Б**

#
в виде множества многоугольников, залитых одним или разными цветами.

4. Изобразить букву
# А

#
в виде множества многоугольников, залитых одним или разными цветами.

5. Изобразить двумерный узор Серпинского

Вписанный треугольник делит стороны внешнего треугольника на равные части. Выполнить не менее 10 итераций.

![](RackMultipart20220915-1-nf07uk_html_1a82ecc24fd5a4b8.gif)

6. Изобразить на экране график функции Y(X) = Sin(πX)/ πX; -5 ≤ X ≤ +5.

Нарисовать координатные Оси X,Y и сделать подписи под рисунком.

7. Изобразить букву
# В

#
в виде множества многоугольников, залитых одним или разными цветами.

8. Изобразить букву
# З

#
в виде множества многоугольников, залитых одним или разными цветами.

9. Изобразить букву
# О

#
в виде множества многоугольников, залитых одним или разными цветами.
